#pragma config(Sensor, dgtl1,  leftWheelsEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightWheelsEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  chainBarEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  liftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  intakeDownBtn,  sensorTouch)
#pragma config(Motor,  port3,           rightWheels,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           claw,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           chainBar,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightLift,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftWheels,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          intake,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(0)
#pragma userControlDuration(60)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//#pragma endregion
//#pragma region Utils
//#pragma endregion
//#pragma region Utils
int JOY_THRESHOLD = 25;
float motor_multiplier[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
int motor_desired[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
bool motor_slew_rate_enabled[10] = {false, true, true, true, true, true, true, true, true, false};
bool motor_slew_rate_enabled_global = true;
int slew_rate_step = 2;
int slew_rate_delay = 10;

task slew_rate()
{
	while(true) {
		for (int i = 0; i < 10; i++)
		{
			if (motor_slew_rate_enabled_global && motor_slew_rate_enabled[i])
			{
				int difference = motor_desired[i] - motor[i];
				int difference_normalized = 0;

				if(difference > 0) {
					difference_normalized = 1 * slew_rate_step * slew_rate_delay;
					if(difference_normalized > difference) {
						difference_normalized = difference;
					}
				}
				else if(difference < 0) {
					difference_normalized = -1 * slew_rate_step * slew_rate_delay;
					if (difference_normalized < difference)
					{
						difference_normalized = difference;
					}
				}

				motor[i] += difference_normalized;
			}
			else {
				motor[i] = motor_desired[i];
			}
		}
		delay(slew_rate_delay);
	}
}

void set_motor(int pin, int speed)
{
	if(pin == -1) {
		return;
	}
	if(speed > 127) {
		speed = 127;
	}
	if(speed < -127) {
		speed = -127;
	}
	motor_desired[pin] = speed * motor_multiplier[pin];
	//motor[pin] = speed * motor_multiplier[pin];
}

int get_joystick_button_direction(int btn1, int btn2)
{
	int direction = (vexRT[btn1]) ? 1 : 0;
	direction = (vexRT[btn2]) ? -1 : direction;
	return direction;
}
//#pragma endregion
//#pragma region PID


float multiplier = 1;
int moveToDesiredPID(int pin, int currentAngle, int reqAngle, float kp, int slave = -1, int lastDiff = 0, float kd = 0, int integral = 0, float ki = 0)
{
	float diff = reqAngle - currentAngle;

	set_motor(pin, (int)(diff * kp) + (int)((lastDiff - diff) * kd) + (int)(integral * ki));
	if (slave != -1)
	{
		set_motor(slave, (int)(diff * kp) + (int)((lastDiff - diff) * kd) + (int)(integral * ki));
	}

	return diff;
}

bool moveToDesired(int pin, int currentAngle, int reqAngle, int slave = -1, float delta = 8.0, float multMaxDeg = 30.0, float maxSpeed = 127.0) {
	int diff = reqAngle - currentAngle;
	float mult = (float)abs(diff) / multMaxDeg;
	if(mult > 1.0) {
		mult = 1;
	}
	mult = pow(mult, 2.0);
	if(abs(diff) < delta) {
		diff = 0;
	}
	if(diff != 0) {
		diff = (diff <= 0)? -1 : 1;
	}
	int speedTemp = (int)(maxSpeed * mult * multiplier);
	set_motor(pin, speedTemp * diff);
	set_motor(slave, speedTemp * diff);
	return (diff == 0);
}


void stopAll()
{
	for (int i = 0; i < 10; i++)
	{
		set_motor(i, 0);
	}
}

float wheelMult = 360.0 / (3.1415926 * 10.16); //360l / 3.14*D
int PID_DELTA = 30;
int PID_DELAY = 1000;
int PID_ITER_DELAY = 10;

void calculateMovementsBase(float wheelLeftDesired, float wheelRightDesired, bool resetEnc = true) {

	if (resetEnc)
	{
		SensorValue[leftWheelsEncoder] = 0;
		SensorValue[rightWheelsEncoder] = 0;
	}
	int wheelLeftError = 0, wheelRightError = 0, chainError = 0, liftError = 0;
	string err1, err2;
	int finishTicks = 0;
	int timeToFinish = 1000;
	while (true)
	{
		wheelLeftError = moveToDesiredPID(leftWheels, SensorValue[leftWheelsEncoder], (int)(wheelLeftDesired * wheelMult), 3, -1, wheelLeftError, 0.5);
		wheelRightError = moveToDesiredPID(rightWheels, -SensorValue[rightWheelsEncoder], (int)(wheelRightDesired * wheelMult), 3, -1, wheelRightError, 0.5);
		if (abs(wheelLeftError) < PID_DELTA ||
			abs(wheelRightError) < PID_DELTA)	{
			stopAll();
			break;
		}
		delay(PID_ITER_DELAY);
	}
	delay(50);
	stopAll();
}
void calculateMovements(float wheelLeftDesired, float wheelRightDesired, int chainDesired, int liftDesired, bool resetEnc = true)
{
	if (resetEnc)
	{
		SensorValue[leftWheelsEncoder] = 0;
		SensorValue[rightWheelsEncoder] = 0;
	}
	int wheelLeftError = 0, wheelRightError = 0, chainError = 0, liftError = 0;
	string err1, err2;
	int finishTicks = 0;
	int timeToFinish = 1000;
	while (true)
	{
		wheelLeftError = moveToDesiredPID(leftWheels, SensorValue[leftWheelsEncoder], (int)(wheelLeftDesired * wheelMult), 0.4, -1, wheelLeftError, 0.5);
		wheelRightError = moveToDesiredPID(rightWheels, SensorValue[rightWheelsEncoder], (int)(wheelRightDesired * wheelMult), 0.4, -1, wheelRightError, 0.5);


		if ((abs(wheelLeftError) < PID_DELTA ||
			abs(wheelRightError) < PID_DELTA) &&
		abs(chainError) < PID_DELTA &&
		abs(liftError) < PID_DELTA)	{
			stopAll();
			break;
		}
		delay(PID_ITER_DELAY);
	}
	delay(50);
	stopAll();
}

int PID_DELTA_NO_BASE = 5;
void calculateMovementsWithoutBase(int chainDesired, int liftDesired, bool resetEnc = true)
{
	int chainIntegral = 0, liftIntegral = 0;
	if (resetEnc)
	{
		SensorValue[liftEncoder] = 0;
		SensorValue[chainBarEncoder] = 0;
	}
	int chainError = 0, liftError = 0;
	while (true)
	{/*
		chainError = moveToDesired(chainBar, SensorValue[chainBarEncoder], chainDesired, 3.5, -1, chainError, 1);
		liftError = moveToDesired(leftLift, SensorValue[liftEncoder], liftDesired, 3.75, rightLift);
		if(abs(chainError) < 15) {
		chainIntegral += chainError;
		}
		else {
		chainIntegral = 0;
		}

		if(abs(liftError) <= 5) {
		liftIntegral += liftError;
		}
		else {
		liftIntegral = 0;
		}
		if (abs(chainError) < 3 && abs(liftError) < 2)
		{
		stopAll();
		break;
		}
		if(vexRT[Btn7R]) {
		stopAll();
		break;
		}
		delay(1);*/
		bool cb = moveToDesired(chainBar, SensorValue[chainBarEncoder], chainDesired, -1, 3.0, 10.0);
		bool lf = moveToDesired(leftLift, SensorValue[liftEncoder], liftDesired, rightLift, 5.0, 2.5);
		if(vexRT[Btn7R] || (cb && lf)) {
			set_motor(chainBar, 0);
			set_motor(leftLift, 0);
			set_motor(rightLift, 0);
			break;
		}
		delay(2);
	}
	set_motor(chainBar, 0);
	set_motor(leftLift, 0);
	set_motor(rightLift, 0);
}

void intake_down()
{
	set_motor(intake, 127);
	delay(500);
	while(SensorValue[intakeDownBtn] == 0) {
		set_motor(intake, 127);
	}
	set_motor(intake, 0);
}

void intake_down_forward(int spd = 60) {
	while(SensorValue[intakeDownBtn] == 0) {
		set_motor(intake, 127);
		set_motor(leftWheels, spd);
		set_motor(rightWheels, spd);
	}
	set_motor(leftWheels, 0);
	set_motor(rightWheels, 0);
	set_motor(intake, 0);
}

void intake_20pt()
{
	set_motor(intake, 127);
	delay(1000);
	set_motor(intake, 0);
	set_motor(leftWheels, 127);
	set_motor(rightWheels, 127);
	delay(1000);
	set_motor(leftWheels, -127);
	set_motor(rightWheels, -127);
	delay(500);
	set_motor(leftWheels, 127);
	set_motor(rightWheels, 127);
	delay(500);
	set_motor(leftWheels, -127);
	set_motor(rightWheels, -127);
}
task keepLiftUp() {
	while(true) {
		bool cb = moveToDesired(chainBar, SensorValue[chainBarEncoder], -5, -1, 3.0, 20.0);
		bool lf = moveToDesired(leftLift, SensorValue[liftEncoder], 20, rightLift, 5.0, 2.5);
		delay(10);
	}
}
void intake_up()
{
	set_motor(intake, -127);
	delay(500);
	while(SensorValue[intakeDownBtn] == 0) {
		set_motor(intake, -127);
	}
	set_motor(intake, 0);
}

void claw_in() {
	set_motor(claw, 127);
	delay(200);
	set_motor(claw, 60);
}

void claw_out() {
	set_motor(claw, -127);
	delay(200);
	set_motor(claw, 0);
}

void pre_auton()
{
  bStopTasksBetweenModes = true;
}

void dunk() {
	stopTask(keepLiftUp);
	while(abs(1 - SensorValue[liftEncoder]) > 6) {
		set_motor(leftLift, -127);
		set_motor(rightLift, -127);
	}
	claw_out();
	startTask(keepLiftUp);
	delay(50);
	set_motor(claw, 0);
}
task autonomous()
{
	SensorValue[leftWheelsEncoder] = 0;
	SensorValue[rightWheelsEncoder] = 0;
	SensorValue[liftEncoder] = 0;
	SensorValue[chainBarEncoder] = 0;
	motor_slew_rate_enabled_global = false;
	startTask(slew_rate);
	startTask(keepLiftUp);
	delay(100);
	/*intake_down_forward(50); //Go forward to
	set_motor(intake, 20);
	calculateMovementsBase(150, 150, false);
	intake_up();
	dunk();
	calculateMovementsBase(-155, -155);

	set_motor(leftWheels, -70);
	set_motor(rightWheels, -30);
	delay(1300);
	set_motor(leftWheels, 0);
	set_motor(rightWheels, 0);

	calculateMovementsBase(13, 13);

	calculateMovementsBase(-29, 29);
	calculateMovementsBase(28, 28);
	calculateMovementsBase(-37, 37);
	calculateMovementsBase(120, 120);
	intake_20pt();
	calculateMovementsBase(-40, -40);
	calculateMovementsBase(35, -35);
	calculateMovementsBase(40, 40);
	calculateMovementsBase(35, -35);
	set_motor(leftWheels, -40);
	set_motor(rightWheels, -40);
	delay(1500);
	set_motor(leftWheels, 0);
	set_motor(rightWheels, 0);*/
	intake_down_forward(20);
	set_motor(intake, 20);
	calculateMovementsBase(110, 110);
	intake_up();
	calculateMovementsBase(-62, 62);
	calculateMovementsBase(120, 120);
	intake_down();

	set_motor(leftWheels, -127);
	set_motor(rightWheels, -127);
	delay(500);
	set_motor(leftWheels, 127);
	set_motor(rightWheels, 127);
	delay(500);
	set_motor(leftWheels, -127);
	set_motor(rightWheels, -127);

	calculateMovementsBase(-10, -10);
	set_motor(intake, -127);
	delay(800);
	set_motor(intake, 0);
	calculateMovementsBase(-62.5, 62.5);

	set_motor(leftWheels, -45);
	set_motor(rightWheels, -45);
	delay(1000);
	set_motor(leftWheels, 0);
	set_motor(rightWheels, 0);

	intake_down_forward(20);
	calculateMovementsBase(170, 170);
	intake_up();

	calculateMovementsBase(100, 100);
	calculateMovementsBase(34, -34);
	calculateMovementsBase(30, 30);
	calculateMovementsBase(-34, 34);
	calculateMovementsBase(120, 120);
	intake_20pt();
	calculateMovementsBase(-40, -40);


	stopAll();
	stopTask(keepLiftUp);
}


int getNumberSign(int a) {
	if(a > 0) {
		return 1;
	}
	else if(a < 0) {
		return -1;
	}
	return 0;
}
//#pragma endregion
//#pragma region UserControl
void control_base()
{
	int leftJoy = (abs(vexRT[Ch3]) > JOY_THRESHOLD) ? vexRT[Ch3] : 0;
	int rightJoy = (abs(vexRT[Ch2]) > JOY_THRESHOLD) ? vexRT[Ch2] : 0;
	leftJoy = (abs(leftJoy) > 100) ? 127 * getNumberSign(leftJoy) : leftJoy;
	rightJoy = (abs(rightJoy) > 100) ? 127 * getNumberSign(rightJoy) : rightJoy;

	set_motor(leftWheels, leftJoy);
	set_motor(rightWheels, rightJoy);
}

bool joystickSetSkills = false;
void control_intake()
{
	set_motor(intake, get_joystick_button_direction(Btn5U, Btn5D) * 127);
}

bool ml_running = false;

task usercontrol()
{
	SensorValue[leftWheelsEncoder] = 0;
	SensorValue[rightWheelsEncoder] = 0;
	SensorValue[liftEncoder] = 0;
	SensorValue[chainBarEncoder] = 0;
	motor_slew_rate_enabled_global = true;
	startTask(slew_rate);
	startTask(keepLiftUp);
	while (true)
	{
		control_base();
		control_intake();
		if(vexRT[Btn7U]) {
			while(vexRT[Btn7U]) { delay(10); }
			stopTask(keepLiftUp);
			while(abs(1 - SensorValue[liftEncoder]) > 3 && !vexRT[Btn7R]) {
				set_motor(leftLift, -127);
				set_motor(rightLift, -127);
			}
			claw_out();
			startTask(keepLiftUp);
			delay(50);
			set_motor(claw, 0);
		}
	}
	stopTask(keepLiftUp);
}
