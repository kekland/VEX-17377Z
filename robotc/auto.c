#pragma config(Sensor, dgtl1,  leftWheelsEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightWheelsEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  liftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  chainBarEncoder, sensorQuadEncoder)
#pragma config(Motor,  port1,           intake,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port3,           rightWheels,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           leftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           chainBar,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           leftWheels,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           claw,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float motor_multiplier[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

int JOY_THRESHOLD = 25;
int motor_desired[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
bool motor_slew_rate_enabled[10] = {false, true, true, true, true, true, true, true, true, true};
bool motor_slew_rate_enabled_global = true;
int slew_rate_step = 2;
int slew_rate_delay = 5;

string savedL1;
string savedL2;
string mainBattery, backupBattery;

void show_page(char *l1, char *l2)
{
	if (l1 != savedL1)
	{
		clearLCDLine(0);
		displayLCDCenteredString(0, l1);
		savedL1 = l1;
	}
	if (l2 != savedL2)
	{
		clearLCDLine(1);
		displayLCDCenteredString(1, l2);
		savedL2 = l2;
	}
}

task slew_rate()
{
	while(true) {
		for (int i = 0; i < 10; i++)
		{
			if (motor_slew_rate_enabled_global && motor_slew_rate_enabled[i])
			{
				int difference = motor_desired[i] - motor[i];
				int difference_normalized = 0;

				if(difference > 0) {
					difference_normalized = 1 * slew_rate_step * slew_rate_delay;
					if(difference_normalized > difference) {
						difference_normalized = difference;
					}
				}
				else if(difference < 0) {
					difference_normalized = -1 * slew_rate_step * slew_rate_delay;
					if (difference_normalized < difference)
					{
						difference_normalized = difference;
					}
				}

				motor[i] += difference_normalized;
			}
			else {
				motor[i] = motor_desired[i];
			}
		}
		delay(slew_rate_delay);
	}
}

void set_motor(int pin, int speed)
{
	if(speed > 127) {
		speed = 127;
	}
	if(speed < -127) {
		speed = -127;
	}
	motor_desired[pin] = (int)(speed * motor_multiplier[pin]);
	//motor[pin] = speed * motor_multiplier[pin];
}

int get_joystick_button_direction(int btn1, int btn2)
{
	int direction = (vexRT[btn1]) ? 1 : 0;
	direction = (vexRT[btn2]) ? -1 : direction;
	return direction;
}
//#pragma endregion
//#pragma region PID

float multiplier = 1;
int moveToDesired(int pin, int currentAngle, int reqAngle, float kp, int slave = -1, int lastDiff = 0, float kd = 0)
{
	float diff = reqAngle - currentAngle;

	set_motor(pin, (int)(diff * kp) + (int)((lastDiff - diff) * kd));
	if(slave != -1)
	{
		set_motor(slave, diff * kp + (lastDiff - diff) * kd);
	}

	return diff;
}

void stopAll() {
	for (int i = 0; i < 10; i++) {
		set_motor(i, 0);
	}
}

float wheelMult = 360.0 / (3.1415926 * 10.16); //360l / 3.14*D
int PID_DELTA = 30;
int PID_DELAY = 1000;
int PID_ITER_DELAY = 10;
void calculateMovements(float wheelLeftDesired, float wheelRightDesired, int chainDesired, int liftDesired, bool resetEnc = true)
{
	if(resetEnc) {
		SensorValue[leftWheelsEncoder] = 0;
		SensorValue[rightWheelsEncoder] = 0;
		SensorValue[liftEncoder] = 0;
		SensorValue[chainBarEncoder] = 0;
	}
	int wheelLeftError = 0, wheelRightError = 0, chainError = 0, liftError = 0;
	string err1, err2;
	int finishTicks = 0;
	int timeToFinish = 1000;
	while (true)
	{
		wheelLeftError = moveToDesired(leftWheels, SensorValue[leftWheelsEncoder], (int)(wheelLeftDesired * wheelMult), 0.4, -1, wheelLeftError, 0.5);
		wheelRightError = moveToDesired(rightWheels, SensorValue[rightWheelsEncoder], (int)(wheelRightDesired * wheelMult), 0.4, -1, wheelRightError, 0.5);
		//chainError = moveToDesired(chainBar, SensorValue[chainBarEncoder], chainDesired, 13);
		//liftError = moveToDesired(leftLift, SensorValue[liftEncoder], liftDesired, 13, rightLift);

		//Display the Primary Robot battery voltage
		sprintf(err1, "Left:%1.2f", wheelLeftError); //Build the value to be displayed

		//Display the Backup battery voltage
		sprintf(err2, "Right:%1.2f", wheelRightError); //Build the value to be displayed
		show_page(err1, err2);

		if(abs(wheelLeftError) < PID_DELTA ||
			abs(wheelRightError) < PID_DELTA) {
				stopAll();
				break;
		}
		delay(PID_ITER_DELAY);
	}
	stopAll();
}

void intake_down() {
	set_motor(intake, 127);
	delay(1550);
	set_motor(intake, 0);
}

void intake_20pt() {
	set_motor(intake, 127);
	set_motor(leftWheels, 127);
	set_motor(rightWheels, 127);
	delay(1550);
	set_motor(intake, 0);
	set_motor(leftWheels, -127);
	set_motor(rightWheels, -127);
}
void intake_up() {
	set_motor(intake, -127);
	delay(1550);
	set_motor(intake, 0);
}

//#pragma endregion
//#pragma region Autonomous
task main()
{
	SensorValue[leftWheelsEncoder] = 0;
	SensorValue[rightWheelsEncoder] = 0;
	startTask(slew_rate);

	show_page("Running", "");

	motor_slew_rate_enabled_global = false;
	intake_20pt();
	calculateMovements(160, 160, 0, 0, false);
	intake_up();
	//calculateMovements(-64, 64, 0, 0);
	calculateMovements(-125, -125, 0, 0);
	calculateMovements(-50, 50, 0, 0);
	calculateMovements(65, 65, 0, 0);
	calculateMovements(-36, 36, 0, 0);
	calculateMovements(100, 100, 0, 0);
	intake_20pt();
	calculateMovements(-100, -100, 0, 0);
	//set_motor(leftWheels, 50);
	//set_motor(rightWheels, 50);
}
