#pragma config(Sensor, dgtl1,  leftWheelsEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightWheelsEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  liftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  chainBarEncoder, sensorQuadEncoder)
#pragma config(Motor,  port1,           intake,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port3,           rightWheels,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           claw,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftLift,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           chainBar,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightLift,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftWheels,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

float motor_multiplier[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
//#pragma region PreAutonomous
bool lcd_buttons_pressed[3] = {false, false, false};

bool lcd_buttons_up[3] = {false, false, false};
bool lcd_buttons_down[3] = {false, false, false};

int lcd_buttons[3] = {1, 2, 4};

string autonomous_names[6] = {"Left 5pt", "Right 5pt", "Left 10pt", "Right 10pt", "Left 20pt", "Right 20pt"};
int autonomous_count = 6;

int selected_autonomous = -1;
int current_page = 0;
int max_pages = 7;

string savedL1;
string savedL2;
string mainBattery, backupBattery;

void show_page(char *l1, char *l2)
{
	if (l1 != savedL1)
	{
		clearLCDLine(0);
		displayLCDCenteredString(0, l1);
		savedL1 = l1;
	}
	if (l2 != savedL2)
	{
		clearLCDLine(1);
		displayLCDCenteredString(1, l2);
		savedL2 = l2;
	}
}

string select = "<  SELECT  >";
void update_page()
{
	if (current_page < autonomous_count)
	{
		//Autonomous page
		show_page(autonomous_names[current_page], select);
	}
	else
	{
		int index = current_page - autonomous_count;
		if (index == 0)
		{
			//Display the Primary Robot battery voltage
			sprintf(mainBattery, "Primary:%1.2f%c", nImmediateBatteryLevel / 1000.0, 'V'); //Build the value to be displayed

			//Display the Backup battery voltage
			sprintf(backupBattery, "Backup:%1.2f%c", BackupBatteryLevel / 1000.0, 'V'); //Build the value to be displayed

			show_page(mainBattery, backupBattery);
		}
	}
}

void handle_lcd_clicks()
{
	if (lcd_buttons_up[0])
	{
		current_page--;
		if (current_page == -1)
		{
			current_page = 0;
		}
	}
	else if (lcd_buttons_up[2])
	{
		current_page++;
		if (current_page == max_pages)
		{
			current_page = max_pages - 1;
		}
	}
	else if (lcd_buttons_up[1] && current_page < autonomous_count)
	{
		selected_autonomous = current_page;
	}
}

void update_lcd_buttons()
{
	for (int i = 0; i < 3; i++)
	{
		bool pressed = (nLCDButtons & lcd_buttons[i]) == lcd_buttons[i];

		lcd_buttons_up[i] = false;
		lcd_buttons_down[i] = false;

		if (lcd_buttons_pressed[i] && !pressed)
		{
			lcd_buttons_up[i] = true;
		}
		else if (!lcd_buttons_pressed[i] && pressed)
		{
			lcd_buttons_down[i] = true;
		}
		lcd_buttons_pressed[i] = pressed;
	}
}

void pre_auton()
{
	bLCDBacklight = true; // Turn on LCD Backlight
	bDisplayCompetitionStatusOnLcd = false;
	bStopTasksBetweenModes = false;
	while (selected_autonomous == -1)
	{
		update_lcd_buttons();
		handle_lcd_clicks();
		update_page();
		delay(100);
	}

	show_page("Selected: ", autonomous_names[selected_autonomous]);
}

//#pragma endregion
//#pragma region Utils
int JOY_THRESHOLD = 25;
int motor_desired[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
bool motor_slew_rate_enabled[10] = {false, true, true, true, true, true, true, true, true, true};
bool motor_slew_rate_enabled_global = true;
int slew_rate_step = 2;
int slew_rate_delay = 10;

task slew_rate()
{
	while(true) {
		for (int i = 0; i < 10; i++)
		{
			if (motor_slew_rate_enabled_global && motor_slew_rate_enabled[i])
			{
				int difference = motor_desired[i] - motor[i];
				int difference_normalized = 0;

				if(difference > 0) {
					difference_normalized = 1 * slew_rate_step * slew_rate_delay;
					if(difference_normalized > difference) {
						difference_normalized = difference;
					}
				}
				else if(difference < 0) {
					difference_normalized = -1 * slew_rate_step * slew_rate_delay;
					if (difference_normalized < difference)
					{
						difference_normalized = difference;
					}
				}

				motor[i] += difference_normalized;
			}
			else {
				motor[i] = motor_desired[i];
			}
		}
		delay(slew_rate_delay);
	}
}

void set_motor(int pin, int speed)
{
	if(speed > 127) {
		speed = 127;
	}
	if(speed < -127) {
		speed = -127;
	}
	motor_desired[pin] = speed * motor_multiplier[pin];
	//motor[pin] = speed * motor_multiplier[pin];
}

int get_joystick_button_direction(int btn1, int btn2)
{
	int direction = (vexRT[btn1]) ? 1 : 0;
	direction = (vexRT[btn2]) ? -1 : direction;
	return direction;
}
//#pragma endregion
//#pragma region PID


float multiplier = 1;
int moveToDesired(int pin, int currentAngle, int reqAngle, float kp, int slave = -1, int lastDiff = 0, float kd = 0)
{
	float diff = reqAngle - currentAngle;

	set_motor(pin, (int)(diff * kp) + (int)((lastDiff - diff) * kd));
	if (slave != -1)
	{
		set_motor(slave, diff * kp + (lastDiff - diff) * kd);
	}

	return diff;
}

void stopAll()
{
	for (int i = 0; i < 10; i++)
	{
		set_motor(i, 0);
	}
}

float wheelMult = 360.0 / (3.1415926 * 10.16); //360l / 3.14*D
int PID_DELTA = 30;
int PID_DELAY = 1000;
int PID_ITER_DELAY = 10;
void calculateMovements(float wheelLeftDesired, float wheelRightDesired, int chainDesired, int liftDesired, bool resetEnc = true)
{
	if (resetEnc)
	{
		SensorValue[leftWheelsEncoder] = 0;
		SensorValue[rightWheelsEncoder] = 0;
		SensorValue[liftEncoder] = 0;
		SensorValue[chainBarEncoder] = 0;
	}
	int wheelLeftError = 0, wheelRightError = 0, chainError = 0, liftError = 0;
	string err1, err2;
	int finishTicks = 0;
	int timeToFinish = 1000;
	while (true)
	{
		wheelLeftError = moveToDesired(leftWheels, SensorValue[leftWheelsEncoder], (int)(wheelLeftDesired * wheelMult), 0.4, -1, wheelLeftError, 0.5);
		wheelRightError = moveToDesired(rightWheels, SensorValue[rightWheelsEncoder], (int)(wheelRightDesired * wheelMult), 0.4, -1, wheelRightError, 0.5);
		chainError = moveToDesired(chainBar, SensorValue[chainBarEncoder], chainDesired, 13);
	  liftError = moveToDesired(leftLift, SensorValue[liftEncoder], liftDesired, 13, rightLift);

		sprintf(err1, "Left:%1.2f", wheelLeftError); //Build the value to be displayed

		sprintf(err2, "Right:%1.2f", wheelRightError); //Build the value to be displayed
		show_page(err1, err2);

		if ((abs(wheelLeftError) < PID_DELTA ||
				abs(wheelRightError) < PID_DELTA) &&
				abs(chainError) < PID_DELTA &&
				abs(liftError) < PID_DELTA)	{
			stopAll();
			break;
		}
		delay(PID_ITER_DELAY);
	}
	stopAll();
}

void intake_down()
{
	set_motor(intake, 127);
	delay(1550);
	set_motor(intake, 0);
}

void intake_20pt()
{
	set_motor(intake, 127);
	set_motor(leftWheels, 127);
	set_motor(rightWheels, 127);
	delay(1550);
	set_motor(intake, 0);
	set_motor(leftWheels, -127);
	set_motor(rightWheels, -127);
}
void intake_up()
{
	set_motor(intake, -127);
	delay(1550);
	set_motor(intake, 0);
}

//#pragma endregion
//#pragma region Autonomous
task autonomous()
{
	SensorValue[leftWheelsEncoder] = 0;
	SensorValue[rightWheelsEncoder] = 0;
	startTask(slew_rate);
	if (selected_autonomous == -1)
	{
		selected_autonomous = 0;
	}

	show_page("Running: ", autonomous_names[selected_autonomous]);

	motor_slew_rate_enabled_global = false;
	if (selected_autonomous == 0)
	{
	}
	else if (selected_autonomous == 1)
	{

	}
	else if(selected_autonomous == 2) {

	}
	else if(selected_autonomous == 3) {

	}
	else if(selected_autonomous == 4) {
		//20pt left
	}
	else if(selected_autonomous == 5) {
		//20pt right
		intake_20pt(); //Go forward to
		calculateMovements(160, 160, 0, 0, false);
		intake_up();
		calculateMovements(-125, -125, 0, 0);
		calculateMovements(-50, 50, 0, 0);
		calculateMovements(65, 65, 0, 0);
		calculateMovements(-36, 36, 0, 0);
		calculateMovements(100, 100, 0, 0);
		intake_20pt();
		calculateMovements(-100, -100, 0, 0);
	}
}

int getNumberSign(int a) {
	if(a > 0) {
		return 1;
	}
	else if(a < 0) {
		return -1;
	}
	return 0;
}
//#pragma endregion
//#pragma region UserControl
void control_base()
{
	int leftJoy = (abs(vexRT[Ch3]) > JOY_THRESHOLD) ? vexRT[Ch3] : 0;
	int rightJoy = (abs(vexRT[Ch2]) > JOY_THRESHOLD) ? vexRT[Ch2] : 0;
	leftJoy = (abs(leftJoy) > 100) ? 127 * getNumberSign(leftJoy) : leftJoy;
	rightJoy = (abs(rightJoy) > 100) ? 127 * getNumberSign(rightJoy) : rightJoy;

	set_motor(leftWheels, leftJoy);
	set_motor(rightWheels, rightJoy);
}

bool joystickSetSkills = false;
void control_intake()
{
	if (joystickSetSkills)
	{
		set_motor(intake, get_joystick_button_direction(Btn5U, Btn5D) * 127);
	}
	else {
		set_motor(intake, get_joystick_button_direction(Btn7U, Btn7D) * 127);
	}
}

void control_lift()
{
	if (joystickSetSkills)
	{
		set_motor(leftLift, get_joystick_button_direction(Btn7D, Btn7U) * -127);
		set_motor(rightLift, get_joystick_button_direction(Btn7D, Btn7U) * -127);
	}
	else {
		set_motor(leftLift, get_joystick_button_direction(Btn5D, Btn5U) * -127);
		set_motor(rightLift, get_joystick_button_direction(Btn5D, Btn5U) * -127);
	}
}

void control_chain_bar()
{
	set_motor(chainBar, get_joystick_button_direction(Btn6U, Btn6D) * -127);
}

void control_claw()
{
	if(vexRT[Btn8U]) {
		set_motor(claw, 127);
	}
	else if(vexRT[Btn8D]) {
		set_motor(claw, -127);
	}
	else {
		set_motor(claw, 40);
}
}

int current_cone = 0;
int max_cones = 14;
int lift_heights[14];
task usercontrol()
{
	show_page("Running:", "Manual Driving");
	SensorValue[leftWheelsEncoder] = 0;
	SensorValue[rightWheelsEncoder] = 0;
	SensorValue[liftEncoder] = 0;
	motor_slew_rate_enabled_global = true;
	while (true)
	{
		control_base();
		control_intake();

		/*if(vexRT[Btn8U]) {
			while(vexRT[Btn8U]) { delay(10); }
			//Move cone
		}
		if(vexRT[Btn8L]) {
			while(vexRT[Btn8L]) { delay(10); }
			current_cone--;
			if(current_cone == -1) {current_cone = 0;}
		}
		if(vexRT[Btn8R]) {
			while(vexRT[Btn8R]) { delay(10); }
			current_cone++;
			if(current_cone == max_cones) {current_cone = max_cones - 1;}
		}
		if(vexRT[Btn8D]) {
			while(vexRT[Btn8D]) { delay(10); }
			current_cone = 0;
		}*/
		control_lift();
		control_chain_bar();
		control_claw();
		delay(10);
	}
}

//#pragma endregion
