#pragma config(Sensor, dgtl1,  leftWheelsEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightWheelsEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  chainBarEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  liftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  intakeDownBtn,  sensorTouch)
#pragma config(Motor,  port2,           rightWheels1,  tmotorNone, openLoop)
#pragma config(Motor,  port3,           rightWheels2,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           claw,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           chainBar,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightLift,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftWheels,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          intake,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Necessary imports n' stuff
#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"


string savedL1; //Saved variable for first line of text
string savedL2; //Saved variable for the second line of text

//Function that is used to show two lines of text on LCD
void show_page(char *l1, char *l2)
{
	//If we have new data on first line - replace it with the new one
	//It is done for optimization and to make functions easier to use
	if (l1 != savedL1)
	{
		clearLCDLine(0); //Clear the 1st line of LCD
		displayLCDCenteredString(0, l1); //Display text on 1st line
		savedL1 = l1; //Save the 1st line in variable
	}
	//Same here, but for the second line
	if (l2 != savedL2)
	{
		clearLCDLine(1); //Clear the second line of LCD
		displayLCDCenteredString(1, l2); //Display text on 2nd line
		savedL2 = l2; //Save the 2nd line in variable
	}
}

int max_pages = 9; //Maximum amount of pages
//Names of our autonomous programs
string autonomous_names[8] = {"None", "Left 5pt", "Right 5pt", "Left 10pt", "Right 10pt", "Left 20pt", "Right 20pt", "Stat. Goal"};
int autonomous_count = 8; //How many autonomous programs do we have

int selected_autonomous = -1; //Currently selected autonomous - default is -1 because none is selected
int current_page = 0; //Current page in LCD screen (1-8 is programs, 9 is battery level)
string select = "<  SELECT  >"; //Temporary string for 2nd line of LCD when choosing program

string mainBattery, backupBattery; //Temporary variables to hold the battery levels
//This function displays text about the current page
void update_page()
{
	//If the current page is autonomous - then display name of the autonomous program and select button
	if (current_page < autonomous_count)
	{
		//Display the page with autonomous program
		show_page(autonomous_names[current_page], select);
	}
	else
	{
		//Else - show the battery level
		int index = current_page - autonomous_count;
		if (index == 0)
		{
			//Display the Primary Robot battery voltage - cast it from Integer to String
			sprintf(mainBattery, "Primary:%1.2f%c", nImmediateBatteryLevel / 1000.0, 'V');

			//Display the Backup battery voltage - cast it from Integer to String
			sprintf(backupBattery, "Backup:%1.2f%c", BackupBatteryLevel / 1000.0, 'V');

			//Display the page with battery levels
			show_page(mainBattery, backupBattery);
		}
	}
}

bool lcd_buttons_pressed[3] = {false, false, false}; //Is the LCD button currently pressed

bool lcd_buttons_up[3] = {false, false, false}; //Did the user raise up the LCD button
bool lcd_buttons_down[3] = {false, false, false}; //Did the user just press on the LCD button

int lcd_buttons[3] = {1, 2, 4}; //0b001, 0b010, 0b100 - the binary numbers of LCD buttons in decimal representation

//This function is called and updates the current states of buttons
void update_lcd_buttons()
{
	//Loop through buttons
	for (int i = 0; i < 3; i++)
	{
		//Get if the button is pressed or not
		bool pressed = (nLCDButtons & lcd_buttons[i]) == lcd_buttons[i];

		//Reset the variables
		lcd_buttons_up[i] = false;
		lcd_buttons_down[i] = false;

		//If button was pressed before and now it is released - that means that user just released the button
		if (lcd_buttons_pressed[i] && !pressed)
		{
			lcd_buttons_up[i] = true;
		}
		//Else if button was not pressed and now it is pressed - that means that user just pressed the button
		else if (!lcd_buttons_pressed[i] && pressed)
		{
			lcd_buttons_down[i] = true;
		}
		lcd_buttons_pressed[i] = pressed; //Set the pressed variable
	}
}

//This function handles the LCD clicks and changes the current page
void handle_lcd_clicks()
{
	//If user clicked the left LCD button and the current page is in the limit - decrease the current page
	if (lcd_buttons_up[0] && current_page > 0)
	{
		current_page--;
	}
	//Else if user clicked the right LCD button and current page is in limit - increase the current page
	else if (lcd_buttons_up[2] && current_page < max_pages - 1)
	{
		current_page++;
	}
	//Or if user clicked the center button and it is page with autonomous program - select it
	else if (lcd_buttons_up[1] && current_page < autonomous_count)
	{
		selected_autonomous = current_page;
	}
}

//Pre-Autonomous function
void pre_auton()
{
	bLCDBacklight = true; //Turn on LCD Backlight
	bDisplayCompetitionStatusOnLcd = false; //Disable the ROBOTC data being displayed on LCD
	bStopTasksBetweenModes = false;

	//While we don't select the autonomous program
	while (selected_autonomous == -1)
	{
		//Update everything
		update_lcd_buttons();
		handle_lcd_clicks();
		update_page();

		//Add little delay for system tasks
		delay(100);
	}

	//If we are finished :
	//Display page that we have selected our program
	show_page("Selected: ", autonomous_names[selected_autonomous]);
}

/*
 * Slew Rate Controller
 * It is used to prevent motor PTC tripping
*/

//This array holds the all desired motor speeds - can be used like 'motor[0] = 127;'
int motor_desired[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

//This array enables or disables the Slew Rate Controller for different motors
bool motor_slew_rate_enabled[10] = {false, true, true, true, true, true, true, true, true, false};
bool motor_slew_rate_enabled_global = true; //Is the Slew Rate Controller enabled globally
int slew_rate_step = 2; //How much speed to add with each iteration
int slew_rate_delay = 5; //Delay between each iteration

task slew_rate()
{
	while(true) {
		//Loop through all motors
		for (int i = 0; i < 10; i++)
		{
			//If Slew Rate is enabled globally and for this motor too
			if (motor_slew_rate_enabled_global && motor_slew_rate_enabled[i])
			{
				int difference = motor_desired[i] - motor[i]; //Calculate the difference
				int difference_change = 0; //This variable holds the difference change

				//If the difference is positive
				if(difference > 0) {
					//Calculate the change and clamp it
					difference_change = 1 * slew_rate_step * slew_rate_delay;
					if (difference_change > difference)
					{
						difference_change = difference; //Clamp the change
					}
				}
				//Else if it is negative
				else if(difference < 0)
				{
					//Calculate the change and clamp it
					difference_change = -1 * slew_rate_step * slew_rate_delay;
					if (difference_change < difference)
					{
						difference_change = difference;
					}
				}

				//Change the motor speed
				motor[i] += difference_change;
			}
			else {
				//If Slew Rate is disabled - set motor speed directly
				motor[i] = motor_desired[i];
			}
		}
		//Delay for other tasks to run properly
		delay(slew_rate_delay);
	}
}

//Speed multipliers for all motors
float motor_multiplier[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

//This function sets the speed for motor
void set_motor(int pin, int speed)
{
	//If motor pin is incorrect - dont set anything
	if(pin < 0 || pin > 9) {
		return;
	}

	//Clamp the speed
	if(speed > 127) {
		speed = 127;
	}
	if(speed < -127) {
		speed = -127;
	}

	//Set the motor speed
	if(pin == rightWheels1 || pin == rightWheels2) {
		motor_desired[rightWheels1] = speed * motor_multiplier[rightWheels1];
		motor_desired[rightWheels2] = speed * motor_multiplier[rightWheels2];
	}
	else {
		motor_desired[pin] = speed * motor_multiplier[pin];
	}
	//motor[pin] = speed * motor_multiplier[pin];
}

//Useful function for getting the direction of two buttons on joystick
//For example : Btn7L and Btn7R
//Returns 1 if Btn7L is pressed and -1 otherwise
int get_joystick_button_direction(int btn1, int btn2)
{
	int direction = (vexRT[btn1]) ? 1 : 0; //If 1st button is pressed - set variable to 1
	direction = (vexRT[btn2]) ? -1 : direction; //If 2nd button is pressed - set variable to -1, otherwise - to previous value
	return direction; //Return the direction
}

//Useful function for getting the normalized value of number (between -1 and 1)
int getNumberSign(int a)
{
	if (a > 0)
	{
		return 1;
	}
	else if (a < 0)
	{
		return -1;
	}
	return 0;
}
/*
 * PID controllers
 * technically - P and PID
*/
//Global multiplier
float multiplier = 1;

//Function that helps with the PID control, could be used as P/PI/PID controllers
int moveToDesiredPID(int pin, int currentAngle, int reqAngle, float kp, int slave = -1, int lastDiff = 0, float kd = 0, int integral = 0, float ki = 0)
{
	float diff = reqAngle - currentAngle; //Get the error

	//Calculate PID
	int pid_speed = (int)(diff * kp) + (int)((lastDiff - diff) * kd) + (int)(integral * ki);

	//Set the speed to motor and its slave
	set_motor(pin, pid_speed);
	set_motor(slave, pid_speed);

	return diff; //Return the error
}

//This function is P and kinda D controller
bool moveToDesired(int pin, int currentAngle, int reqAngle, int slave = -1, float delta = 8.0, float multMaxDeg = 30.0, float maxSpeed = 127.0) {
	//Calculate the error
	int diff = reqAngle - currentAngle;
	float mult = (float)abs(diff) / multMaxDeg; //Calculate the multiplier for the speed - if it is close to the target

	if(mult > 1.0) {
		mult = 1; //If multiplier is more than 1 - set it to one
	}
	mult = pow(mult, 2.0); //Power the multiplier by 2 so that the curve will be parabolic, not linear

	//If motor is close to target - stop
	if(abs(diff) < delta) {
		diff = 0;
	}
	//Else, calculate the normal value for speed (-1 to 1)
	if(diff != 0) {
		diff = (diff <= 0)? -1 : 1;
	}

	//Set the speed for the motor and its slave
	int speedTemp = (int)(maxSpeed * mult * multiplier);
	set_motor(pin, speedTemp * diff);
	set_motor(slave, speedTemp * diff);

	//Return True if we have reached the value, False otherwise
	return (diff == 0);
}

//Function to stop all motors
void stopAll()
{
	for (int i = 0; i < 10; i++)
	{
		set_motor(i, 0); //Loop through all motors and set them all to zero
	}
}

float wheelMult = 360.0 / (3.1415926 * 10.16); //This constants has the wheel circumference to turn angle ratio

//Delta value for PID (drivetrain)
int PID_DELTA = 30;
//Delay between each PID iteration
int PID_ITER_DELAY = 10;

//This function calculates the movements for the base (drivetrain)
void calculateMovementsBase(float wheelLeftDesired, float wheelRightDesired, bool resetEnc = true) {
	//If we need to reset encoders - reset them
	if (resetEnc)
	{
		SensorValue[leftWheelsEncoder] = 0;
		SensorValue[rightWheelsEncoder] = 0;
	}
	int wheelLeftError = 0, wheelRightError = 0; //These variables contain the error for left and right wheels
	while (true)
	{
		//Move with PID controller
		wheelLeftError = moveToDesiredPID(leftWheels, SensorValue[leftWheelsEncoder], (int)(wheelLeftDesired * wheelMult), 3, -1, wheelLeftError, 0.5);
		wheelRightError = moveToDesiredPID(rightWheels1, SensorValue[rightWheelsEncoder], (int)(wheelRightDesired * wheelMult), 3, -1, wheelRightError, 0.5);

		//If we are close to our target - stop and return
		if (abs(wheelLeftError) < PID_DELTA || abs(wheelRightError) < PID_DELTA)	{
			set_motor(leftWheels, 0);
			set_motor(rightWheels1, 0);
			break;
		}
		delay(PID_ITER_DELAY);
	}
	//Stop motors
	set_motor(leftWheels, 0);
			set_motor(rightWheels1, 0);
}

//This function calculates the movements for lift and chainbar
void calculateMovementsWithoutBase(int chainDesired, int liftDesired, bool resetEnc = true)
{
	//If we need to reset encoders - reset them
	if (resetEnc)
	{
		//SensorValue[liftEncoder] = 0;
		//SensorValue[chainBarEncoder] = 0;
	}
	while (true)
	{
		//Move with P controller
		bool cb = moveToDesired(chainBar, SensorValue[chainBarEncoder], chainDesired, -1, 3.0, 15.0);
		bool lf = moveToDesired(leftLift, SensorValue[liftEncoder], liftDesired, rightLift, 4.0, 6.5);

		//If we have finished or we need to cancel our moves (with 7R button) - stop
		if(vexRT[Btn7R] || (cb && lf)) {
			set_motor(chainBar, 0);
			set_motor(leftLift, 0);
			set_motor(rightLift, 0);
			break;
		}

		//Delay for other tasks
		delay(2);
	}

	//Stop motors
	set_motor(chainBar, 0);
	set_motor(leftLift, 0);
	set_motor(rightLift, 0);
	delay(100);
}

//This function releases the intake from drivetrain (to get the mobile goal)
void intake_down()
{
	set_motor(intake, 127); //Move intake forwards
	delay(500);
	//While we are not hitting the button below - move
	while(SensorValue[intakeDownBtn] == 0) {
		set_motor(intake, 127);
	}
	//Stop
	set_motor(intake, 0);
}

//This function releases the intake and drives forward
void intake_down_forward(int spd = 60)
{
	//While we are not hitting the button below - move the intake and drivetrain
	while(SensorValue[intakeDownBtn] == 0) {
		set_motor(intake, 127);
		set_motor(leftWheels, spd);
		set_motor(rightWheels1, spd);
	}
	//Stop
	set_motor(leftWheels, 0);
	set_motor(rightWheels1, 0);
	set_motor(intake, 0);
}

//This function releases the mobile goal into 20pt zone
void intake_20pt()
{
	//Release the intake
	set_motor(intake, 127);
	delay(1000);
	//Shake the drivetrain so mobile goal will fall out from it
	set_motor(intake, 0);
	set_motor(leftWheels, 127);
	set_motor(rightWheels1, 127);
	delay(700);
	set_motor(leftWheels, -127);
	set_motor(rightWheels1, -127);
	delay(500);
	set_motor(leftWheels, 127);
	set_motor(rightWheels1, 127);
	delay(500);
	set_motor(leftWheels, -127);
	set_motor(rightWheels1, -127);
}

//This function gets the intake into drivetrain
void intake_up()
{
	set_motor(intake, -127);
	delay(500);
	//While we are not hitting the button below (with mobile goal that we are raising up) - move the intake
	while(SensorValue[intakeDownBtn] == 0) {
		set_motor(intake, -127);
	}
	//Stop
	set_motor(intake, 0);
}

//This task keeps the lift in upper position - useful for autonomous tasks
task keepLiftUp()
{
	while (true)
	{
		//Move to desired upper position with P controller
		moveToDesired(chainBar, SensorValue[chainBarEncoder], -5, -1, 3.0, 20.0);
		moveToDesired(leftLift, SensorValue[liftEncoder], 20, rightLift, 5.0, 2.5);
		delay(10);
	}
}

//This function sucks the cone into the rollers
void claw_in() {
	set_motor(claw, 127); //Grab the cone
	delay(300);
	set_motor(claw, 60); //Keep small amount of power on motor to keep cone from falling
}

//This function sucks the cone out of the rollers
void claw_out() {
	set_motor(claw, -127); //Release the cone
	delay(300);
	set_motor(claw, 0);
}

//This function performs the "dunk" move - puts the cone into mobile goal below it
void dunk() {
	stopTask(keepLiftUp); //Stop our task that keeps the lift in upper position
	//While we are not in target height - move downwards
	while(abs(1 - SensorValue[liftEncoder]) > 6) {
		set_motor(leftLift, -127);
		set_motor(rightLift, -127);
	}
	claw_out(); //Release the cone
	startTask(keepLiftUp); //Restart our task that keeps the lift in upper position
	delay(50);
	set_motor(claw, 0);
}

/*
 * Autonomous code
*/

task autonomous()
{
	//Reset the encoders
	SensorValue[leftWheelsEncoder] = 0;
	SensorValue[rightWheelsEncoder] = 0;
	SensorValue[liftEncoder] = 0;
	SensorValue[chainBarEncoder] = 0;

	//Start the slew rate controller
	startTask(slew_rate, kHighPriority);

	//If we somehow did not select our autonomous - do nothing
	if (selected_autonomous == -1)
	{
		selected_autonomous = 0;
	}

	//Show that we are running the autonomous
	show_page("Running: ", autonomous_names[selected_autonomous]);

	//Disable the slew rate for precision
	motor_slew_rate_enabled_global = false;
	if(selected_autonomous == 0) {
		//None
		//Do nothing
	}
	else if (selected_autonomous == 1)
	{
		//5 points Left
		startTask(keepLiftUp);									 //Keep the lift up
		delay(100);															 //Add little delay so the lift will not disturb the intake
		intake_down_forward(50);								 //Release the intake and drive forward slowly
		set_motor(intake, 20);									 //Set the intake motor for little power so that it will be fully touching the ground
		calculateMovementsBase(150, 150, false); //Move for 150cm forward
		intake_up();														 //Get the mobile goal to the base
		dunk();																	 //Perform the "dunk" action
		calculateMovementsBase(-125, -125);			 //Go 125cm backwards
		calculateMovementsBase(75, -75);				 //Rotate 180deg
		intake_down();													 //Put the mobile goal into 5 point zone
		calculateMovementsBase(-30, -30);				 //Go backwards for a little bit
		stopTask(keepLiftUp);										 //Stop keeping the lift up
	}
	else if (selected_autonomous == 2)
	{
		//5 points Right
		startTask(keepLiftUp);									 //Keep the lift up
		delay(100);															 //Add little delay so the lift will not disturb the intake
		intake_down_forward(50);								 //Release the intake and drive forward slowly
		set_motor(intake, 20);									 //Set the intake motor for little power so that it will be fully touching the ground
		calculateMovementsBase(150, 150, false); //Move for 150cm forward
		intake_up();														 //Get the mobile goal to the base
		dunk();																	 //Perform the "dunk" action
		calculateMovementsBase(-125, -125);			 //Go 125cm backwards
		calculateMovementsBase(-75, 75);				 //Rotate 180deg
		intake_down();													 //Put the mobile goal into 5 point zone
		calculateMovementsBase(-30, -30);				 //Go backwards for a little bit
		stopTask(keepLiftUp);										 //Stop keeping the lift up
	}
	else if(selected_autonomous == 3) {
		//10 points Left
		startTask(keepLiftUp);									 //Keep the lift up
		delay(100);															 //Add little delay so the lift will not disturb the intake
		intake_down_forward(50);								 //Release the intake and drive forward slowly
		set_motor(intake, 20);									 //Set the intake motor for little power so that it will be fully touching the ground
		calculateMovementsBase(150, 150, false); //Move for 150cm forward
		intake_up();														 //Get the mobile goal to the base
		dunk();																	 //Perform the "dunk" action
		calculateMovementsBase(-125, -125);			 //Go 125cm backwards
		calculateMovementsBase(75, -75);				 //Rotate 180deg
		calculateMovementsBase(50, 50);					 //Go forwards into 10 point zone
		intake_down();													 //Put the mobile goal into 10 point zone
		calculateMovementsBase(-30, -30);				 //Go backwards for a little bit
		stopTask(keepLiftUp);										 //Stop keeping the lift up
	}
	else if(selected_autonomous == 4) {
		//10 points Right
		startTask(keepLiftUp);									 //Keep the lift up
		delay(100);															 //Add little delay so the lift will not disturb the intake
		intake_down_forward(50);								 //Release the intake and drive forward slowly
		set_motor(intake, 20);									 //Set the intake motor for little power so that it will be fully touching the ground
		calculateMovementsBase(150, 150, false); //Move for 150cm forward
		intake_up();														 //Get the mobile goal to the base
		dunk();																	 //Perform the "dunk" action
		calculateMovementsBase(-125, -125);			 //Go 125cm backwards
		calculateMovementsBase(-75, 75);				 //Rotate 180deg
		calculateMovementsBase(50, 50);					 //Go forwards into 10 point zone
		intake_down();													 //Put the mobile goal into 10 point zone
		calculateMovementsBase(-30, -30);				 //Go backwards for a little bit
		stopTask(keepLiftUp);										 //Stop keeping the lift up
	}
	else if(selected_autonomous == 5) {
		//20 points Left
		startTask(keepLiftUp);									 //Keep the lift up
		delay(100);															 //Add little delay so the lift will not disturb the intake
		intake_down_forward(50);								 //Release the intake and drive forward slowly
		set_motor(intake, 20);									 //Set the intake motor for little power so that it will be fully touching the ground
		calculateMovementsBase(150, 150, false); //Move for 150cm forward
		intake_up();														 //Get the mobile goal to the base
		dunk();																	 //Perform the "dunk" action
		calculateMovementsBase(-125, -125);			 //Go 125cm backwards
		calculateMovementsBase(-50, 50);				 //Rotate something like 135 degrees
		calculateMovementsBase(70, 70);					 //Move forward for the center of starting bar
		calculateMovementsBase(-35, 35);				 //Rotate for 90 degrees
		calculateMovementsBase(110, 110);				 //Reach the 20 point zone
		intake_20pt();													 //Put the mobile goal there
		calculateMovementsBase(-80, -80);				 //Go back
		stopTask(keepLiftUp);										 //Stop keeping the lift upwards
	}
	else if(selected_autonomous == 6) {
		//20pt right
		startTask(keepLiftUp);									 //Keep the lift up
		delay(100);															 //Add little delay so the lift will not disturb the intake
		intake_down_forward(50);								 //Release the intake and drive forward slowly
		set_motor(intake, 20);									 //Set the intake motor for little power so that it will be fully touching the ground
		calculateMovementsBase(150, 150, false); //Move for 150cm forward
		intake_up();														 //Get the mobile goal to the base
		dunk();																	 //Perform the "dunk" action
		calculateMovementsBase(-125, -125);			 //Go 125cm backwards
		calculateMovementsBase(50, -50);				 //Rotate something like 135 degrees
		calculateMovementsBase(70, 70);					 //Move forward for the center of starting bar
		calculateMovementsBase(35, -35);				 //Rotate for 90 degrees
		calculateMovementsBase(110, 110);				 //Reach the 20 point zone
		intake_20pt();													 //Put the mobile goal there
		calculateMovementsBase(-80, -80);				 //Go back
		stopTask(keepLiftUp);										 //Stop keeping the lift upwards
	}
	else if(selected_autonomous == 7) {
		//Stationary Goal - put the preload cone to stationary goal
		//This is experimental
		calculateMovementsBase(60, 60, false); //Go forward for 60cm
		calculateMovementsWithoutBase(-5, 35, false); //Raise the lift
		calculateMovementsWithoutBase(-35, 35, false); //Put the chainbar to right position
		claw_out(); //Release the cone
		delay(100);
		set_motor(claw, 0);
	}
	motor_slew_rate_enabled_global = true;
}

/*
 * Manual Driving
 * My code is split up into different parts so it will be easier to tune some variables or turn off some part
*/

int JOY_THRESHOLD = 25; //Constant variable for the "Dead Zone" of joystick

//This function controls the base (drivetrain)
void control_base()
{
	int leftJoy = (abs(vexRT[Ch3]) > JOY_THRESHOLD) ? vexRT[Ch3] : 0; //Get the left joystick value and compare with dead zone
	int rightJoy = (abs(vexRT[Ch2]) > JOY_THRESHOLD) ? vexRT[Ch2] : 0; //Get the right joystick value and compare with dead zone
	leftJoy = (abs(leftJoy) > 100) ? 127 * getNumberSign(leftJoy) : leftJoy; //If value is bigger than 100 - set it to 127
	rightJoy = (abs(rightJoy) > 100) ? 127 * getNumberSign(rightJoy) : rightJoy; //If value is bigger than 100 - set it to 127

	//Set motors
	set_motor(leftWheels, leftJoy);
	set_motor(rightWheels1, rightJoy);
}

//This function controls the intake
void control_intake()
{
	//Control the intake
	set_motor(intake, get_joystick_button_direction(Btn7U, Btn7D) * 127);
}

//This function controls the lifts
void control_lift()
{
	//Control the left and right side of lift
	set_motor(leftLift, get_joystick_button_direction(Btn5D, Btn5U) * -127);
	set_motor(rightLift, get_joystick_button_direction(Btn5D, Btn5U) * -127);
}

//This function controls the chain bar
void control_chain_bar()
{
	//Control the chainbar
	set_motor(chainBar, get_joystick_button_direction(Btn6U, Btn6D) * 127);
}

//Variable that checks if match loads algorithm is running or not
bool ml_running = false;

//This function controls the claw
void control_claw()
{
	//Joystick movements
	if(vexRT[Btn5UXmtr2]) {
		set_motor(claw, 127);
	}
	else if(vexRT[Btn5DXmtr2]) {
		set_motor(claw, -127);
	}
	//If we are below 40 degrees - activate the claw automatically
	else if(!ml_running && SensorValue[chainBarEncoder] < -40) {
		set_motor(claw, 50);
	}
	//If match loads is running - stop
	else if(!ml_running) {
		set_motor(claw, 0);
	}
}

//Those variables contain the current cone and maximum amount of cones that we can stack
int current_cone = 0;
int max_cones = 10;

void control_cones() {
	if(vexRT[Btn8LXmtr2]) { //If we press the 8L button on partner joystick
		while(vexRT[Btn8LXmtr2]) { delay(10); } //Wait for its release
		current_cone--; //Decrement the cone counter
		if(current_cone == -1) {current_cone = 0;} //Clamp the value
	}
	if(vexRT[Btn8RXmtr2]) { //If we press the 8R button on partner joystick
		while(vexRT[Btn8RXmtr2]) { delay(10); } //Wait for its release
		current_cone++; //Increment the cone counter
		if(current_cone == max_cones) {current_cone = max_cones - 1;} //Clamp the value
	}
	if(vexRT[Btn8DXmtr2]) { //If we press the 8D on partner joystick
		while(vexRT[Btn8DXmtr2]) { delay(10); } //Wait for its release
		current_cone = 0; //Reset the cone counter
	}
}

//This function performs the "dunk" move - puts the cone into mobile goal below it
void dunk_matchloads(int cc)
{
	//While we are not on target position - move downwards
	while (abs((int)(cc * 7) - 1 - SensorValue[liftEncoder]) > 5 && !vexRT[Btn7LXmtr2])
	{
		set_motor(leftLift, -127);
		set_motor(rightLift, -127);
	}
	//Stop the lift and release the cone
	set_motor(leftLift, 0);
	set_motor(rightLift, 0);
	delay(300);
	set_motor(claw, -127);
	delay(450);
}

task keep_position() {
	SensorValue[leftWheelsEncoder] = 0;
	SensorValue[rightWheelsEncoder] = 0;

	int wheelLeftError = 0, wheelRightError = 0; //These variables contain the error for left and right wheels
	while (true)
	{
		//Move with PID controller
		wheelLeftError = moveToDesiredPID(leftWheels, SensorValue[leftWheelsEncoder], 0, 3, -1, wheelLeftError, 0.5);
		wheelRightError = moveToDesiredPID(rightWheels1, SensorValue[rightWheelsEncoder], 0, 3, -1, wheelRightError, 0.5);

		delay(PID_ITER_DELAY);
	}
	//Stop motors
	set_motor(leftWheels, 0);
	set_motor(rightWheels1, 0);
}
void control_matchloads() {
	//If we press the 7R button on partner joystick
	if(vexRT[Btn7RXmtr2]) {
		while(vexRT[Btn7RXmtr2]) { delay(10); } //Wait for its release
		startTask(keep_position);
		ml_running = true; //Set that we are running the match loads
		motor_slew_rate_enabled_global = false; //Disable the Slew Rate controller

		//Do everything automatically
		while(current_cone < 10 && !vexRT[Btn7LXmtr2]) {
			/*calculateMovementsWithoutBase(0, height, false);	 //Raise the lift up to max. height and keep the chain bar vertical
			calculateMovementsWithoutBase(-74, height, false); //While keeping the lift up to max. make chain bar horizontal
			calculateMovementsWithoutBase(-74, 25, false);		 //Move to matchloads height while keeping the chain bar horizontal
			delay(200);
			claw_in();																				 //Get the cone
			calculateMovementsWithoutBase(-74, height, false); //Move back to max. height with chain bar being horizontal
			calculateMovementsWithoutBase(0, height, false);	 //Make chain bar vertical while keeping the max. height
			dunk_matchloads(current_cone);										 //Perform dunk
			current_cone++;										//Increment the cone counter*/
			int height = 25;
			if(8 + (int)((current_cone) * 6.5) > height) {
				height = 10 + (int)((current_cone) * 6.5);
			}
			calculateMovementsWithoutBase(-10, height, false);
			calculateMovementsWithoutBase(-76, height, false);
			while(SensorValue[liftEncoder] > 24) {
				set_motor(leftLift, -90);
				set_motor(rightLift, -90);
				set_motor(claw, 80);
			}
			set_motor(leftLift, 0);
			set_motor(rightLift, 0);
			claw_in();
			calculateMovementsWithoutBase(-76, height, false);
			calculateMovementsWithoutBase(-10, height, false);
			dunk_matchloads(current_cone);
			delay(250);
			current_cone++;
		}
		ml_running = false; //Disable the match loads
		motor_slew_rate_enabled = true; //Enable the slew rate controller
		stopTask(keep_position);
	}
}

void control_autostack() {
	//If we press the right button
	if (vexRT[Btn8UXmtr2]) {
		while (vexRT[Btn8UXmtr2]) { //Wait for its release
			delay(10);
		}
		motor_slew_rate_enabled_global = false;																		//Disable the slew rate controller
		claw_in();																																//Get the cone
		calculateMovementsWithoutBase(-85, 11 + (int)(current_cone * 6.5), false); //While keeping the chainbar horizontal raise up to max. height
		set_motor(claw, 60);																											//Keep the claw pulling the cone inwards
		calculateMovementsWithoutBase(-10, 10 + (int)(current_cone * 6.5), false);	//Make the chainbar vertical while keeping the max.height
		delay(250);
		dunk_matchloads(current_cone);																					  //Perform dunk
		current_cone++;																														//Increment the cone counter
		set_motor(claw, -127);																										//Keep the claw pushing the cones outwards
		calculateMovementsWithoutBase(-10, 9 + (int)(current_cone * 6.5), false);	//Move lift to max.height while keeping the chainbar vertical
		set_motor(claw, -127);																										//Keep the claw pushing the cones outwards
		calculateMovementsWithoutBase(-85, 10 + (int)(current_cone * 6.5), false); //Move chainbar to horizontal position
		set_motor(claw, 0);																												//Release the claw
		calculateMovementsWithoutBase(-85, 0, false);															//Move lift downwards
		delay(250);
		stopAll();
		motor_slew_rate_enabled_global = true; 																		//Enable slew rate controller
	}
}

task usercontrol()
{
	//Show that we are currently in manual mode
	show_page("Running:", "Manual Driving");

	//Enable the Slew Rate controller
	motor_slew_rate_enabled_global = true;
	while (true)
	{
		control_base();
		control_intake();

		control_autostack();
		control_matchloads();
		control_cones();
		control_lift();
		control_chain_bar();
		control_claw();

		delay(5);
	}
}
